<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhangJY_blog</title>
  
  
  <link href="https://zhangjy1014.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhangjy1014.github.io/"/>
  <updated>2023-03-24T13:35:15.532Z</updated>
  <id>https://zhangjy1014.github.io/</id>
  
  <author>
    <name>ZhangJY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ch1_操作系统概述</title>
    <link href="https://zhangjy1014.github.io/2023/03/24/Ch1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://zhangjy1014.github.io/2023/03/24/Ch1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2023-03-24T12:41:25.000Z</published>
    <updated>2023-03-24T13:35:15.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch1-操作系统概述"><a href="#Ch1-操作系统概述" class="headerlink" title="Ch1_操作系统概述"></a>Ch1_操作系统概述</h1><p align="center"><a href="https://github.com/zhangjy1014" target="view_window"><img alt="GitHub" src="https://img.shields.io/badge/Github-@zhangjy1014-000000.svg?style=flat-square&logo=Github"></a><a href="https://space.bilibili.com/434002748"><img src="https://img.shields.io/badge/B%E7%AB%99-@Lil_SuiSad-000000.svg?style=flat-square&logo=Bilibili"></a></p><p>[toc]</p><h2 id="OS基础知识"><a href="#OS基础知识" class="headerlink" title="OS基础知识"></a>OS基础知识</h2><h3 id="OS的意义"><a href="#OS的意义" class="headerlink" title="OS的意义"></a>OS的意义</h3><p>什么是OS：1. 管理系统中的各种软硬件资源    2. 为用户提供良好的界面    </p><p>操作系统是一种管理计算机系统各种软硬件资源的系统软件，位于硬件层之上，所有其他软件层之下的系统软件，用来进行CPU管理、存储器管理、I/O设备管理、文件管理。</p><h3 id="OS的作用"><a href="#OS的作用" class="headerlink" title="OS的作用"></a>OS的作用</h3><h4 id="功能（4个）"><a href="#功能（4个）" class="headerlink" title="功能（4个）"></a>功能（4个）</h4><ol><li>CPU管理； 2. 存储器管理； 3. $I/O$设备管理； 4. 文件管理</li></ol><h4 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h4><p>​    操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的第一次扩充。OS在计算机系统中占据着重要地位，其他软件都依赖于它的支持，是与硬件关系最密切的==系统软件==</p><h3 id="为什么要学OS"><a href="#为什么要学OS" class="headerlink" title="为什么要学OS"></a>为什么要学OS</h3><h2 id="OS相关知识"><a href="#OS相关知识" class="headerlink" title="OS相关知识"></a>OS相关知识</h2><h3 id="OS历史"><a href="#OS历史" class="headerlink" title="OS历史"></a>OS历史</h3><h4 id="手工阶段"><a href="#手工阶段" class="headerlink" title="手工阶段"></a>手工阶段</h4><p>步骤：</p><ol><li>将程序和数据记录在打孔纸带上</li><li>将程序的纸带放到光电输入机，通过控制台开关启动光电机将程序输入内存</li><li>通过控制台启动程序，从第一条指令开始运行</li><li>运行结果传输到打印机输出</li></ol><p>缺点：</p><ol><li>用户在处理作业的整个过程中要独占系统的全部资源</li><li>手工操作所需时间长</li></ol><h4 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h4><h5 id="联机批处理"><a href="#联机批处理" class="headerlink" title="联机批处理"></a>联机批处理</h5><img src="https://s2.loli.net/2022/07/16/HPfedSiUI7tXEa9.png" alt="image-20220603155920940" style="zoom:33%;"><p>原理：操作员将若干作业合成为一批，按照卡片顺序依次放到读卡器，监督程序Monitor通过内存将这批作业传输到磁带机（大量作业在磁带机上排队等待处理）。输入完毕后，监督程序开始处理这批作业。自动将第一个作业读入内存，并对其进行编译、链接、执行、输出。处理完第一个处理第二个，如此往复。直到所有都处理完再处理下一批。</p><p>优点：作业自动转换，缩短了手工操作时间；出现了Monitor及相关软件的支持</p><p>缺点：作业由读卡机到磁带机的传输需要<strong>处理机</strong>完成,由于设备的传输速度远低于处理机的速度, 在此传输过程中处理机仍会浪费较多时间。即==I/O设备与CPU直接相连==，CPU(主机)浪费。实际上还是处理机利用monitor程序来处理I/O。</p><h5 id="脱机批处理"><a href="#脱机批处理" class="headerlink" title="脱机批处理"></a>脱机批处理</h5><img src="https://s2.loli.net/2022/07/16/4Q3RCUwf6uctshM.png" alt="image-20220603161150702" style="zoom:33%;"><p>原理：待处理的作业由==卫星机==负责经读卡机传送到输入磁带上，主机从输入磁带读入作业、加以处理，并把处理结果送到输出磁带上，最后由卫星机负责将输出磁带上的结果在打印机上输出。</p><p>优点：卫星机与主机分工明确，并行工作； 提高了CPU的运行效率</p><p>缺点：单任务系统；需人工拆装磁带</p><h5 id="执行系统阶段"><a href="#执行系统阶段" class="headerlink" title="执行系统阶段"></a>执行系统阶段</h5><p>通道(channel)：$I/O$处理机， 通道的I/O操作能与处理机的计算工作完全并行，并能在I/O操作结束后向处理机发出中断请求</p><p>中断(interrupt)：中断是指当主机接到某种外部信号时，马上暂停当前正在执行的任务，转去处理这一中断事件，处理完毕后返回原来的断点继续工作。</p><p>假脱机(spooling)：作业由读卡机到存储区的传输以及运行结果由存储区到打印机的传输由通道完成，既不是脱机，也不是联机（也不依靠卫星机）。<br>假脱机优点：通道替代卫星机，免去手工装卸磁带的麻烦。</p><h3 id="OS完善"><a href="#OS完善" class="headerlink" title="OS完善"></a>OS完善</h3><h4 id="多道批处理阶段-Multi-programming-System"><a href="#多道批处理阶段-Multi-programming-System" class="headerlink" title="多道批处理阶段(Multi-programming System)"></a>多道批处理阶段(Multi-programming System)</h4><p>原理：多道作业。用户提交的作业都先放在外存上并排成一个后备队列，然后由作业调度程序按一定的算法从后备队列中选择<strong>若干个作业</strong>调入<strong>内存</strong>。当一道作业因等待I/O传输完成等原因暂时不能运行时，系统可将CPU资源分配给另一个可运行的作业。</p><p>本质上是将若干个程序调入到内存，使他们交替执行，CPU就始终处于忙状态。</p><p>宏观上并行：多个作业调入内存，同时占有资源各自运行<br>微观上串行：轮流占有处理机，交替执行</p><p>优点：资源利用率高，吞吐量大<br>缺点：平均周转时间长，缺乏交互能力</p><h4 id="分时系统-Time-sharing-System"><a href="#分时系统-Time-sharing-System" class="headerlink" title="分时系统(Time-sharing System)"></a>分时系统(Time-sharing System)</h4><p>原理：在一台主机上连接多个显示器和键盘的终端，允许多个用户共享主机资源，以终端方式使用主机，每个用户都像是独占这台主机。</p><p>多路性：一个主机与多个终端相连，系统按分时原则为每个用户服务。宏观上，多个用户同时工作,共享系统资源；微观上，每个用户轮流运行一个时间片。</p><p>交互性：以对话的方式为用户服务</p><p>独占性：每个终端用户仿佛都拥有一台虚拟机</p><h4 id="实时系统-Real-time-System"><a href="#实时系统-Real-time-System" class="headerlink" title="实时系统(Real-time System)"></a>实时系统(Real-time System)</h4><p>实时系统是指系统能即时响应外部事件的请求，在规定时间内完成对事件的处理，并控制所有实时任务协调一致地运行。它分为实时信息处理系统和实时控制系统两大类。</p><h4 id="通用系统"><a href="#通用系统" class="headerlink" title="通用系统"></a>通用系统</h4><p>将多道批处理、分时和实时等功能结合在一起构造出的多功能的操作系统。</p><h3 id="操作系统基本特性（4个）"><a href="#操作系统基本特性（4个）" class="headerlink" title="操作系统基本特性（4个）"></a>操作系统基本特性（4个）</h3><h4 id="程序的并发性"><a href="#程序的并发性" class="headerlink" title="程序的并发性"></a>程序的并发性</h4><p>程序的并发指计算机系统同时存在多个程序，宏观上，这些程序同时向前推进。</p><p>并发：宏观上同时，微观上轮流交替<br>并行：微观上同时，需要多个处理器</p><p>并发是计算机系统的重要特征，其他特征都是以并发为前提。</p><h4 id="资源的共享性"><a href="#资源的共享性" class="headerlink" title="资源的共享性"></a>资源的共享性</h4><p>操作系统程序与用户程序共用系统中的各种资源，这种共享是在操作系统的控制下实现的</p><p><strong>互斥共享</strong>：系统中有一些资源，当一个进程正在访问该资源时，其他进程必须等待，直到该进程访问完并释放这些资源时，其他进程才能访问这些资源。这就是互斥共享，互斥共享的资源叫<strong>临界资源</strong>。如：打印机等物理设备或者表格就是临界资源，它们要求互斥共享。（不能同时）</p><p><strong>同时共享：</strong>系统中有一类资源，允许在一段时间内，由多个进程同时对其访问。这就是同时共享，本质还是宏观上时同时，微观上是交替分时的。如，磁盘，同时可以多个进程访问磁盘。</p><h4 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h4><p>不确定性。程序交替执行需要中断，中断是不确定的，所以操作系统中的运行轨迹是异步的，不可预知的。比如先进入内存的作业可能比后进入的后完成。</p><h4 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h4><p>把物理上的一个变成逻辑上的多个。（分时、分空间）</p><h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a><del>操作系统的分类</del></h3><h4 id="多道批处理操作系统"><a href="#多道批处理操作系统" class="headerlink" title="多道批处理操作系统"></a>多道批处理操作系统</h4><img src="https://s2.loli.net/2022/07/16/WwqPHVb6dF3UBfS.png" alt="image-20220603170341310" style="zoom:33%;"><p>作业（Job）：用户程序，数据，程序说明书</p><p>输入井：用来保存已经输入、尚未处理的作业。外存</p><p>输出井：用来保存处理完毕、尚未输出的结果。外存</p><p>结果：程序运行结果+记账信息</p><h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><img src="https://s2.loli.net/2022/07/16/spTafqo5Fzl1mxD.png" alt="image-20220603170617913" style="zoom:33%;"><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>实时控制、实时信息处理</p><p>。。。。</p><h3 id="硬件环境（8大）"><a href="#硬件环境（8大）" class="headerlink" title="硬件环境（8大）"></a>硬件环境（8大）</h3><ol><li><p>时钟装置：        绝对时钟：记载实际时间、不断发生            间隔时钟（闹钟）：定期发生中断</p></li><li><p>系统栈： 内存中操作系统空间中的一个固定区域。   </p><pre><code>作用：保存中断现场、保存子程序间相互嵌套调用的信息（中间参数）。       </code></pre><p>*每个运行程序都有一个对应系统栈；进程切换伴随系统栈切换</p></li><li><p>特权指令和非特权指令。 特权指令：只有在管态下才能执行的指令<br>非特权指令：管态和目态均可执行的指令</p></li><li><p>处理机状态<br>管态：操作系统运行时所处的状态。处于管态时可以执行硬件提供的全部指令（特权指令、非特权指令）。在管态下可通过执行特权指令修改程序状态字PSW，改变机器状态，实现管态与目态切换。<br>目态：一般用户程序运行时所处的状态。只能执行非特权指令</p><p>管态=》目态   通过==修改程序状态字==(PSW)来实现。由于操作系统运行于管态，用户程序运行于目态，该状态转换必包括从操作系统程序切换到用户程序。<br>目态=》管态   唯一途径：==中断==     用户程序在目态下运行时不能直接使用I/O指令等特权指令。只有当用户程序执行到==访管指令==产生一次中断后，使机器在原来的目态下执行用户程序变成在管态下执行操作系统的系统调用程序。所以从目态转换成管态的唯一途径是中断。</p></li><li><p>地址映射机构：将逻辑地址变为物理地址</p></li><li><p>存储保护设施：进行地址越界和越权检查，防止应用程序侵犯操作系统空间或其他应用空间</p></li><li><p>中断装置：发现中断、响应中断</p></li><li><p>通道与DMA控制器：     通道：负责I/O处理，有自己的指令系统和运控部件</p><pre><code>DMA(Direct Memory Access):数据在内存与块型设备的简单传输</code></pre></li></ol><h3 id="界面形式"><a href="#界面形式" class="headerlink" title="界面形式"></a><del>界面形式</del></h3><ol><li>交互终端命令（图形用户界面）</li><li>作用控制语言</li><li>系统调用命令</li></ol><h3 id="运行机理"><a href="#运行机理" class="headerlink" title="运行机理"></a>运行机理</h3><p>现代OS是中断驱动的</p><p>中断是程序切换的必要条件&lt;程序切换必有中断&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ch1-操作系统概述&quot;&gt;&lt;a href=&quot;#Ch1-操作系统概述&quot; class=&quot;headerlink&quot; title=&quot;Ch1_操作系统概述&quot;&gt;&lt;/a&gt;Ch1_操作系统概述&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://githu</summary>
      
    
    
    
    <category term="Computer Science" scheme="https://zhangjy1014.github.io/categories/Computer-Science/"/>
    
    
    <category term="OS" scheme="https://zhangjy1014.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Ch2_进程线程与作业</title>
    <link href="https://zhangjy1014.github.io/2023/03/24/Ch2-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BD%9C%E4%B8%9A/"/>
    <id>https://zhangjy1014.github.io/2023/03/24/Ch2-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BD%9C%E4%B8%9A/</id>
    <published>2023-03-24T12:41:25.000Z</published>
    <updated>2023-03-24T13:38:42.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch-2进程线程与作业"><a href="#Ch-2进程线程与作业" class="headerlink" title="Ch_2进程线程与作业"></a>Ch_2进程线程与作业</h1><p align="center"><a href="https://github.com/zhangjy1014" target="view_window"><img alt="GitHub" src="https://img.shields.io/badge/Github-@zhangjy1014-000000.svg?style=flat-square&logo=Github"></a><a href="https://space.bilibili.com/434002748"><img src="https://img.shields.io/badge/Bilibili-@LilSuiSad-000000.svg?style=flat-square&logo=Bilibili"></a></p><p>[toc]</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="一个概念：吞吐量"><a href="#一个概念：吞吐量" class="headerlink" title="一个概念：吞吐量"></a>一个概念：吞吐量</h3><p>单位时间内系统所处理的作业的道数。是衡量系统效率的一个尺度。</p><p>$吞吐量 = \frac{作业道数}{全部处理时间}$</p><h3 id="单道的缺点（3个）"><a href="#单道的缺点（3个）" class="headerlink" title="单道的缺点（3个）"></a>单道的缺点（3个）</h3><ol><li>设备资源利用率低</li><li>内存资源利用率低</li><li>处理机资源利用率低。中断、通道、DMA控制器的引入，可以使处理器与IO设备并行运行</li></ol><h3 id="多道的优点（3个）"><a href="#多道的优点（3个）" class="headerlink" title="多道的优点（3个）"></a>多道的优点（3个）</h3><ol><li>设备资源利用率提高</li><li>内存资源利用率提高</li><li>处理机资源利用率提高</li></ol><p>问：内存中的程序数量是否越多越好？<br>答：不是。1. 内存容量限制了系统可以同时处理的程序数量。2. 物理设备的数量也制约。 3.内存中过多的程序会形成处理机资源的激烈竞争。 结论：增加同时运行的程序道数可提高系统资源利用率，从而提高系统效率，但道数应该与系统资源数量相当。道数过少，资源利用率低；过多，系统开销大，程序响应速度下降。</p><h3 id="多道程序面对的问题（3个）"><a href="#多道程序面对的问题（3个）" class="headerlink" title="多道程序面对的问题（3个）"></a>多道程序面对的问题（3个）</h3><ol><li>处理机资源管理问题。实现处理机资源在各个程序之间的分配和调度。</li><li>内存资源管理问题<ol><li>内存划分问题</li><li>逻辑地址映射到内存物理地址（重定位）</li><li>存储空间的保护</li></ol></li><li>设备资源管理问题。程序使用资源的不确定性，内存的多道程序运行时会产生冲突，所以需要对设备资源加以分配与管理。</li></ol><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程引入"><a href="#进程引入" class="headerlink" title="进程引入"></a>进程引入</h3><p>多道程序系统的一个程序活动规律：执行暂停执行暂停……<br>多道程序运行需要保存现场。</p><h3 id="进程的基本知识（9）"><a href="#进程的基本知识（9）" class="headerlink" title="进程的基本知识（9）"></a>进程的基本知识（9）</h3><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h4><p>进程定义：进程是程序的一次执行。/进程是可参与并发执行的程序。/<br>                  进程是一个程序与数据通过处理机的执行所发生的活动。/<br>                  进程是一个程序在给定的空间和初始环境下，在一个处理机上的执行过程。/<br>                  进程是具有一定独立功能的程序关于一个数据集合的一次运行活动。</p><p>并发：宏观同时，微观交替<br>并行：微观同时，多个CPU才能实现</p><h4 id="进程状态及状态转换"><a href="#进程状态及状态转换" class="headerlink" title="进程状态及状态转换"></a>进程状态及状态转换</h4><p>进程状态：<br>==运行态(RUN)==：进程占有CPU向前推进，单处理机系统中任一时刻只能有一个进处于运行态<br>==就绪态(READY)==：进程本身具有运行条件，但暂未得到CPU<br>==等待态(WAIT)<del>阻塞</del>==：进程正等待某一事件的发生，即使给它分配处理机也不能运行<br>三个最基本的，可能还有别的<br>*进程等待态/挂起态、阻塞态、封锁态、睡眠态</p><p><img src="https://s2.loli.net/2022/07/16/jED1lFtYhurTmes.png" alt="image-20220614195132981" style="zoom:35%;">                               <img src="https://s2.loli.net/2022/07/16/gV1PS5G7K94l8TU.png" alt="image-20220614195143939" style="zoom:35%;"></p><p>进程状态转换：</p><p>就绪-&gt;运行：获得处理机（进程调度）<br>运行-&gt;就绪：剥夺处理机（时间片满）<br>运行-&gt;等待：申请资源未得到，启动IO传输未完成（IO或事件请求）<br>等待-&gt;就绪：得到所申请资源，IO传输完成（IO完成或等待时间发生）</p><p>进程状态转换由操作系统完成，对用户透明。</p><h4 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h4><p>断点保存区域设在进程控制块中，进程控制块是进程存在的标志。</p><p>进程控制块是标志进程存在的数据结构，其中包含系统对进程管理所需要的全部信息。是进程实体的一部分，是描述和控制、管理进程的记录性数据结构。</p><img src="https://s2.loli.net/2022/07/16/5X3qol6GSPYgzUB.png" alt="image-20220614195841789" style="zoom:33%;"><h4 id="进程的组成和上下文"><a href="#进程的组成和上下文" class="headerlink" title="进程的组成和上下文"></a>进程的组成和上下文</h4><p>进程组成：PCB、操作集、数据集</p><ol><li><p>PCB存在于==系统空间==，只有操作系统能够对其存取，用户程序不能访问。</p></li><li><p>程序包括代码和数据两部分。</p></li></ol><p>进程上下文：进程的物理实体与支持进程运行的物理环境。<br>                      ==进程切换过程就是进程上下文切换的过程。==</p><p>系统开销：操作系统程序，对系统进行管理而花费的时间和空间。</p><h4 id="进程队列（PCB链）"><a href="#进程队列（PCB链）" class="headerlink" title="进程队列（PCB链）"></a>进程队列（PCB链）</h4><p>进程队列实际上是由进程PCB构成的队列。</p><p>分类：</p><ol><li>就绪队列。 整个系统一个，一个就绪队列包含多个就绪进程</li><li>执行队列。单CPU系统一个，多CPU系统多个。每个队列只有一个进程</li><li>阻塞队列。一个等待/阻塞原因一个，系统有多个，1个队列包含多个因同样原因等待/阻塞的进程。</li></ol><h4 id="进程类型和特性"><a href="#进程类型和特性" class="headerlink" title="进程类型和特性"></a>进程类型和特性</h4><p>类型：</p><ol><li>系统进程：属于OS的一部分，运行OS程序，完成OS的某些功能，对应无限循环程序，系统启动后一直存在，直到系统关闭。属于管态，优先级高于一般用户进程。</li><li>用户进程：运行用户程序，直接为用户服务。在目态运行。</li></ol><p>特性：</p><ol><li>并发性：宏观上与其他进程同时向前推进</li><li>动态性：进程是执行的程序。动态产生、动态消亡；在进程的生存期内，动态变化</li><li>独立性：进程是调度的基本单位，可单独获得处理机参与并发执行。</li><li>交往性：与其他进程发生直接或间接相互作用。</li><li>异步性：每个进程都以相对独立、不可预知的速度向前推进。</li><li>结构性：每个进程都有一个进程控制块PCB</li></ol><h4 id="进程的相互联系和相互作用"><a href="#进程的相互联系和相互作用" class="headerlink" title="进程的相互联系和相互作用"></a>进程的相互联系和相互作用</h4><p>相互联系：相关进程：在逻辑上具有某种联系的进程<br>                  无关进程：逻辑上没有任何联系的进程。无关进程间没有逻辑关系，但会竞争资源。</p><p>相互作用：</p><p>直接相互作用（直接制约）：进程间不需要中间媒介就能发生相互作用。==只发生在相关进程之间==。有意识</p><p>间接相互作用（间接制约）：进程间需要中间媒介才能发生的相互作用。==可发生在任意进程之间==。无意识</p><h4 id="进程的创建和撤销"><a href="#进程的创建和撤销" class="headerlink" title="进程的创建和撤销"></a>进程的创建和撤销</h4><p>进程创建fork() ：1.建立一个PCB，对内容进行初始化。<br>2.为该进程分配存储空间，加载所需要的执行程序。3. 将PCB送人就绪队列。</p><p>进程结束exit()：1.完成的进程需终止自己并告知OS。系统通过exit系统调用实现。</p><img src="https://s2.loli.net/2022/07/16/LqVyFSagdmPMKD5.png" alt="image-20220614204327869" style="zoom:50%;"><p>==进程的创建与结束属于OS中的系统调用，而其它状态转换条件对应OS核心中的内部函数。==</p><h4 id="进程和程序的联系和差别"><a href="#进程和程序的联系和差别" class="headerlink" title="进程和程序的联系和差别"></a>进程和程序的联系和差别</h4><p>联系：</p><p>程序是构成进程的组成部分之一，一个进程存在的目的就是对应其程序，没有程序，进程也就没有了意义。</p><p>差别：</p><ol><li>程序是静态的，进程是动态的</li><li>程序可长期保存，进程具有生存期，创建后存在，撤销后消亡。</li><li>一个程序可对应多个进程，一个进程只对应一个程序。</li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>同一个任务中存在不同的多个执行流。</p><h3 id="线程的基本知识"><a href="#线程的基本知识" class="headerlink" title="线程的基本知识"></a>线程的基本知识</h3><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>线程(thread)也可称轻进程(LWP)，==是进程内的一个相对独立的执行流。==</p><ol><li>一个进程可包含多个线程</li><li>同一个进程中的线程可能执行统一程序中的相同或不同的代码段，共享数据区和堆</li><li>进程是资源的分配单位，线程是处理机分配单位（核心级线程）</li></ol><p>进程是资源的分配单位，线程是CPU的调度单位。线程是比进程更小的能独立运行的基本单位</p><h4 id="线程的性质（4个）"><a href="#线程的性质（4个）" class="headerlink" title="线程的性质（4个）"></a>线程的性质（4个）</h4><ol><li>轻型实体</li><li>独立调度和分派的基本单位</li><li>可并发执行</li><li>共享进程资源</li></ol><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><ol><li>状态参数。每个线程用线程标识符和一组状态参数描述</li><li>运行状态：执行状态、就绪状态、阻塞状态</li></ol><h4 id="线程的创建和撤销"><a href="#线程的创建和撤销" class="headerlink" title="线程的创建和撤销"></a>线程的创建和撤销</h4><p>创建：进程在启动运行时，首先给它创建一个被称为“初始化线程”，运行的线程可根据需要再去创建若干个线程。在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数（如主程序的入口指针、堆栈的大小、优先级等），在线程创建函数执行完后，将返回一个线程标识符供以后使用。</p><p>终止线程的方式有两种：一种是在线程完成了自己的工作后自愿退出；<br>另一种是线程在运行中出现错误或由于某种原因而被其它线程强行终止。</p><h4 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h4><ol><li>上下文切换速度快</li><li>系统开销小</li><li>通讯容易</li></ol><h4 id="线程的结构"><a href="#线程的结构" class="headerlink" title="线程的结构"></a>线程的结构</h4><img src="https://s2.loli.net/2022/07/16/iXkGqoj314J9bpP.png" alt="image-20220614205510596" style="zoom:50%;"><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><h5 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h5><p>在目态实现，处于用户空间。用户级线程有系统库支持；创建、撤销、状态转换都是由系统库库函数完成；TCP在用户空间由系统库维护。</p><p>注意：</p><ol><li>用户级线程对OS不可见</li><li>系统调度以进程为单位</li><li>系统栈个数和进程个数对应</li></ol><h5 id="中间系统"><a href="#中间系统" class="headerlink" title="中间系统"></a>中间系统</h5><p>用户级线程要取得内核服务通过中间系统</p><p>实现：运行时系统runtime：系统库，runtime，JRE，CLR，用户空间。用户控制线程LWP</p><img src="https://s2.loli.net/2022/07/16/3kPJTvMynSKtWl6.png" alt="image-20220614210048124" style="zoom:50%;"><p>用户级别线程优点：</p><ol><li>线程不依赖于OS</li><li>线程之间的切换速度快</li></ol><h5 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h5><p>在管态实现，处于系统空间。线程的创建、撤销、状态转换由OS完成，TCB在系统空间由OS维护。</p><h5 id="混合线程"><a href="#混合线程" class="headerlink" title="混合线程"></a>混合线程</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ch-2进程线程与作业&quot;&gt;&lt;a href=&quot;#Ch-2进程线程与作业&quot; class=&quot;headerlink&quot; title=&quot;Ch_2进程线程与作业&quot;&gt;&lt;/a&gt;Ch_2进程线程与作业&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://g</summary>
      
    
    
    
    <category term="Computer Science" scheme="https://zhangjy1014.github.io/categories/Computer-Science/"/>
    
    
    <category term="OS" scheme="https://zhangjy1014.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Ch3_中断与处理机调度</title>
    <link href="https://zhangjy1014.github.io/2023/03/24/Ch3-%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    <id>https://zhangjy1014.github.io/2023/03/24/Ch3-%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</id>
    <published>2023-03-24T12:41:25.000Z</published>
    <updated>2023-03-24T13:39:36.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch3-中断与处理机调度"><a href="#Ch3-中断与处理机调度" class="headerlink" title="Ch3_中断与处理机调度"></a>Ch3_中断与处理机调度</h1><p align="center"><a href="https://github.com/zhangjy1014" target="view_window"><img alt="GitHub" src="https://img.shields.io/badge/Github-@zhangjy1014-000000.svg?style=flat-square&logo=Github"></a><a href="https://space.bilibili.com/434002748"><img src="https://img.shields.io/badge/Bilibili-@LilSuiSad-000000.svg?style=flat-square&logo=Bilibili"></a></p><p>[toc]</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="中断引入"><a href="#中断引入" class="headerlink" title="中断引入"></a>中断引入</h3><p>操作系统是中断驱动的。</p><p>为什么要引入中断：    CPU的高速与外设的低速不匹配，采用软件查询方式，程序轮询。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>定义: 在程序运行过程中,出现了某种紧急事件,处理机必须中止当前正在运行的程序,转去处理此事件,然后再恢复原来运行的程序,这个过程称作中断。</p><p>中断的硬件实现：中断装置</p><p>中断的软件实现：中断处理程序</p><p>中断系统：中断装置+中断处理程序</p><h3 id="中断装置"><a href="#中断装置" class="headerlink" title="中断装置"></a>中断装置</h3><p>中断装置是用于==发现并响应==中断的==硬件==机构。</p><p><strong>工作过程</strong>（中断响应过程）：==识别中断源==（选择优先级最高的中断源）、==保存中断现场==（将正在运行的进程的程序状态字PSW和指令计数器PC中的内容压入系统栈）、==转入中断处理程序==（将与中断事件相对应的中断向量由内存指定单元处取出并PSW和PC，如此便转入对应的中断处理程序）</p><img src="https://s2.loli.net/2022/07/16/ytjQc6GgrYBNbLi.png" alt="image-20220616210002176" style="zoom:50%;"><p><strong>中断向量</strong>：中断源的识别标志,可用来形成相应的中断服务程序的入口地址或存放中断服务程序的首地址。</p><p><strong>中断源</strong>:引起中断的事件称为中断源；</p><p><strong>中断字</strong>：中断寄存器中的内容；</p><p><strong>中断请求</strong>:中断源向CPU提出处理的请求；</p><p><strong>断点</strong>:发生中断时被打断程序的暂停点；</p><p><strong>中断响应</strong>:CPU暂停现行程序而转为响应中断请求的过程；</p><p><strong>中断处理程序</strong>:处理中断源的程序；</p><p><strong>中断处理</strong>:CPU执行有关的中断处理程序；</p><p><strong>中断返回</strong>:返回断点的过程；</p><p>处于关中断状态下执行的程序段应尽量短,否则会影响系统的并发性。(为什么？)</p><p>中断是进程切换的必要条件，如果关了中断，则操作系统无法获得处理机的控制权，也就无法使多个进程分时共享处理机。在关中断期间，一个进程独占处理机。所以说“关中断”会影响系统的并发性</p><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>中断处理程序的主要工作</p><p>保存中断现场：关中断、保存、开中断</p><p>处理中断事件</p><p>恢复正常操作</p><p>由核心返回目态程序时，进程的PSW和PC为何必须用一条机器指令同时恢复？<br>进程的程序状态字PSW和指令计数器PC的内容必须由一条指令同时恢复，这样才能保证系统状态由管态转到目态的同时，控制转到上升进程的断点处继续执行。</p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="基本调度"><a href="#基本调度" class="headerlink" title="基本调度"></a>基本调度</h3><p>处理机调度是指将CPU资源在可运行实体之间的分配。（核心级）线程是CPU资源分配的基本单位，如果线程是在用户级实现的，操作系统实际调度的实体是进程。</p><p>从资源角度看,该算法确定了处理机的分配策略, 故称其为<strong>处理机调度算法</strong>；<br>从资源使用者角度看,该算法确定了进程运行的次序,故称其为<strong>进程调度算法</strong>。 </p><p>处理机调度需要解决的问题：<br>确定调度算法（分配原则）、确定调度时机（何时分配）、给出调度过程（如何分配）</p><p>进程调度的两种方式：<br>非抢占式：不允许某进程抢占已经分配出去的处理机<br>抢占方式：允许调度程序根据某种原则，暂停正在执行的进程，将处理机重新分配给另一进程</p><p>抢占原则：优先权原则、短作业（进程）优先原则、时间片原则</p><h4 id="调度算法（8大）"><a href="#调度算法（8大）" class="headerlink" title="调度算法（8大）"></a>调度算法（8大）</h4><ol><li><p>先到先服务算法 (First-Come, First-Served, FCFS)<br>按照进程申请CPU的次序(即进程进入就绪状态的次序)进行调度。非抢占式。</p><p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。<img src="https://s2.loli.net/2022/07/16/3WojsitaDMVONlH.png" alt="image-20220618163851843" style="zoom:50%;"></p></li><li><p>短作业优先 (Shortest Job First，SJF)<br>按<strong>CPU阵发时间</strong>由小到大的次序调度。</p><p>对长作业不利，容易造成极端现象</p><img src="https://s2.loli.net/2022/07/16/9NOu8P3TKGos5MZ.png" alt="image-20220618164237380" style="zoom:50%;"><img src="https://s2.loli.net/2022/07/16/4LoliusdYfCOm9k.png" alt="image-20220619095344844" style="zoom:50%;"></li><li><p>最高响应比优先 (Highest Response Ratio Next,HRN) </p><img src="https://s2.loli.net/2022/07/16/1qXfep7an8MOu4S.png" alt="image-20220618170114095" style="zoom:50%;">                                                                    $优先权(响应比) = \frac{等待时间+执行时间}{执行时间}$，优先权大的先执行</li><li><p>最高优先数法 (Highest Priority First，HPF)<br>优先数法的基本思想：每个进程的PCB中有一个用数字表示的优先数。当需要进行处理机分配时,系统在可运行进程中选择优先数最高者使其投入运行。<br>进程优先数的大小应与进程所对应事件的紧迫程度相对应。如果一个进程所对应事件比较紧迫,则其优先数应较高；如果一个进程所对应事件不太紧迫,则其优先数可较低。可见，进程的优先数反映了进程运行的优先级别，故又称为优先级法。<br>静态优先数、动态优先数<br>优点：资源利用率高，公平性好；缺点：开销较大，实现较为复杂</p></li><li><p>循环轮转法 (Round Robin，RR)<br>循环轮转算法的基本思想：系统为每个进程规定一个时间片(time slice),所有进程按其时间片的长短轮流地运行。<br>基本轮转：时间片长度相同且不变<br>改进轮转：时间片长度不同或可变</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长</li></ul><p>适合于分时系统</p></li><li><p>分类排队法 (Multi Level Queues，MLQ)<br>多个就绪队列将系统中所有可运行进程按某种原则加以分类,进程被分入不同的就绪队列中。</p><img src="https://s2.loli.net/2022/07/16/Tboimfe2saYcGk4.png" alt="image-20220618192035062" style="zoom:50%;"></li><li><p>最短剩余时间法 (Shortest Remaining Time Next, SRTN) </p><p>可剥夺的短作业优先调度算法<br>当CPU空闲时，选择剩余时间最短的进程或线程。   当一个新进程或线程到达时，若新进程比当前运行进程的的剩余运行时间短则切换运行进程可剥夺。</p></li><li><p>反馈排队法 (Feed Back，FB)<br>有多个进程就绪队列,每个队列中通常采用时间片轮转调度算法；每个队列的时间片不同；进程可以在不同的就绪队列之间移动。<br> 短进程优先处理、设备资源利用率高、系统开销小</p></li></ol><p>进程运行需要处理机资源、IO操作需要设备资源，两类交替占用<br>==CPU阵发期==：对处理器的一次连续使用<br>==I/O阵发期==：对设备的一次连续使用<br>进程运行行为：    CPU阵发期→I/O阵发期→CPU阵发期→…→I/O阵发期→CPU阵发期 （执行暂停执行暂停）<br>==阵发时间==：处于CPU阵发期的进程所需要的处理时间</p><p>==周转时间==(turnaround time)：由就绪开始时刻到处理完毕时刻的时间；       结束时间-提交(到达)时间<br>==带权周转时间==：周转时间/运行时间<br>==平均周转时间==(average …)：所有进程的周转时间之和与进程个数的比值；<br>==等待时间==：周转时间与处理时间之差；<br>==平均等待时间==：所有进程的等待时间之和与进程个数的比值。</p><p>==非剥夺式调度==（非抢占式调度）：一个进程不能从正在运行的进程那抢占CPU<br>剥夺式调度：一个进程可以从正在运行的进程那抢占CPU</p><h4 id="性能评价指标"><a href="#性能评价指标" class="headerlink" title="性能评价指标"></a>性能评价指标</h4><p>CPU利用率、吞吐量、周转时间、响应时间、系统开销</p><p>何时发生调度？   进程切换（一个进程占有处理机）的时候会发生处理机调度</p><p>何时可能调用处理机调度程序？  首先要有==中断==，进入到管态；其次要发生==进程切换==</p><p>何时会发生进程切换?  中断完成后，原进程不具备运行条件，就一定会发生进程切换; 原进程具备运行条件，则可能切换也可能不切换，就和调度策略有关</p><p>什么中断会产生切换?    一定会切换的中断，进程运行终止的中断，进程等待资源中断，请求I/O中断等; 可能引起切换的中断，时钟中断….等。</p><p>中断是进程切换的必要条件<br>中断是系统由用户态转换为系统态的必要条件。据此,假如在时刻T1与时刻T2之间发生了进程切换,则在时刻T1与时刻T2之间一定发生过中断。中断是进程切换的前提,也可以说，操作系统是中断驱动的。</p><p><strong>下降进程</strong>指的是当前即将被中断运行的进程。<br><strong>上升进程</strong>指的是按照调度算法从就绪队列中选择的一个即将被运行的进程。</p><p>处理机调度过程：</p><ol><li>保存下降调度现场。保存下降进程现场到其进程控制块PCB中。 (系统栈=&gt;PCB)<br>==中断响应时==, 中断装置将被中断进程的中断向量压入系统栈。<br>==中断响应后==, 中断处理程序将被中断进程的其它断点信息,如寄存器内容等压入系统栈。<br>==中断处理后==, 若需进程切换,则将系统栈中的现场信息弹出,送入下降进程的PCB。</li><li>选择将要运行到进程。处理机调度算法在就绪队列中选择一个进程，使其投入运行</li><li>恢复上升进程现场。由于进程下降时已将其现场信息保存在对应的PCB中,故进程上升时由其PCB中的信息恢复现场(PCB=&gt;寄存器)。</li></ol><h3 id="调度级别和多级调度"><a href="#调度级别和多级调度" class="headerlink" title="调度级别和多级调度"></a>调度级别和多级调度</h3><h4 id="三个级别"><a href="#三个级别" class="headerlink" title="三个级别"></a>三个级别</h4><p>处理机调度（进程调度）、中级调度、高级调度（作业调度）</p><img src="https://s2.loli.net/2022/07/16/o6WkUBMmXJ1jhea.png" alt="image-20220618195452654" style="zoom:50%;"><h4 id="交换调度（中级）"><a href="#交换调度（中级）" class="headerlink" title="交换调度（中级）"></a>交换调度（中级）</h4><p>交换是进程在内存与外存之间的调度，引入一个挂起态</p><p>为什么说中级调度能减少并发度从而降低系统开销？<br><strong>中级调度</strong>是系统<strong>控制并发度</strong>的一个调度级别。系统并发度过高时，将内存中的某些进程暂时<strong>交换</strong>到外存，待系统并发度较低时再调回内存。    </p><img src="https://s2.loli.net/2022/07/16/IYDrz2aUyEiuFZb.png" alt="image-20220618200106698" style="zoom:50%;"><h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><p><strong>实时调度</strong>：满足实时任务各自时间约束条件的调度称为<strong>实时调度</strong>。</p><p><strong>实时任务</strong>：具有明确时间约束的计算任务，如某时刻前必须开始处理，某时刻前必须处理完毕等。</p><p>指标（7个）</p><p><strong>就绪时间</strong>(ready time)：实时任务产生并<strong>可以开始处理</strong>的时间称为就绪时间；</p><p><strong>开始截止期</strong>(starting deadline)：实时任务最迟开始处理时间称为开始截止期；</p><p><strong>处理时间</strong>(processing time)：实时任务处理所需要的处理机时间称为处理时间；</p><p><strong>完成截止期</strong>(completion deadline)：实时任务最迟完成时间称为完成截止期；</p><p><strong>发生周期</strong>(occurring period)：周期性实时任务的发生间隔时间称为发生周期；</p><p><strong>发生频率</strong>(Occurring frequency)：单位时间内实时周期性任务发生的次数称为发生频率。</p><p><strong>优先级</strong>：实时任务的相对紧迫程度。</p><p>实时调度的必要条件：</p><p>​            $\sum_{i=1}^{n}\frac{C_i}{T-i}\geq1$</p><p>算法：</p><ol><li>最早截止期优先算法(EDF)</li><li>速率单调调度(RMS)</li><li>最低松弛度优先（LLF）</li></ol><h3 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ch3-中断与处理机调度&quot;&gt;&lt;a href=&quot;#Ch3-中断与处理机调度&quot; class=&quot;headerlink&quot; title=&quot;Ch3_中断与处理机调度&quot;&gt;&lt;/a&gt;Ch3_中断与处理机调度&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="Computer Science" scheme="https://zhangjy1014.github.io/categories/Computer-Science/"/>
    
    
    <category term="OS" scheme="https://zhangjy1014.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Ch4_互斥同步与通讯</title>
    <link href="https://zhangjy1014.github.io/2023/03/24/Ch4-%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E8%AE%AF/"/>
    <id>https://zhangjy1014.github.io/2023/03/24/Ch4-%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E8%AE%AF/</id>
    <published>2023-03-24T12:41:25.000Z</published>
    <updated>2023-03-24T13:40:23.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch4-互斥同步与通讯"><a href="#Ch4-互斥同步与通讯" class="headerlink" title="Ch4_互斥同步与通讯"></a>Ch4_互斥同步与通讯</h1><p>[toc]</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><p>有向无环图，表示进程执行的先后顺序。<br>前趋、后继。<br>初始结点：没有前趋结点，终止结点：没有后继结点<br>每个结点可以有权重，表示该结点包含的程序量或执行时间</p><h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><ol><li>内部顺序性：对于一个进程内，所有指令按序执行。<br>S1-&gt;S2-&gt;S3….</li><li>外部顺序性：对于多个进程（进程间），所有进程活动依次执行<br>P1-&gt;P2-&gt;P3…</li></ol><p>特点：</p><ol><li>顺序性：严格按照次序。</li><li>封闭性：程序运行过程中独占系统的全部资源，不受其他程序和外界因素影响。</li><li>可再现性：执行结果只与初始条件有关。</li></ol><h3 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h3><ol><li><p>内部并发性：程序内部并发<br><img src="https://s2.loli.net/2022/07/16/hCKxRbdsm2rPTn3.png" alt="image-20220601170634081"></p></li><li><p>外部并发性：程序直接并发</p><img src="https://s2.loli.net/2022/07/16/GWIug3clnTjv75U.png" alt="image-20220601170646378" style="zoom:50%;"></li></ol><p>特点：</p><ol><li>交叉性：一个程序的某些指令可交叉执行</li><li>非封闭性：资源不独占</li><li>不可再现性：每次运行的并发情况不同（并发执行结果不唯一）</li><li>间断性：执行-暂停-执行-暂停</li></ol><h3 id="进程并发执行的条件"><a href="#进程并发执行的条件" class="headerlink" title="进程并发执行的条件"></a>进程并发执行的条件</h3><p>==读集（R集）==：程序Pi在执行过程中需要读取的变量的集合</p><p>==写集（W集）==：程序Pi在执行过程中需要改变的所有变量的集合</p><p>例：有语句$c = a + b, v = c -1$，<br>读集：$R(c:=a+b)={a,b},\quad R(v:=c-1)={c}$</p><p>写集：$$W(c:=a+b)={c},\quad W(v:=c- 1)={v}$$</p><p>伯恩斯坦条件：若程序p1, p2满足以下条件，则能够保持可再现性，因而可以并发执行：</p><p>$$R(p1)∩W(p2)∪R(p2)∩W(p1)∪W(p1)∩W(p2)=Φ$$</p><h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><h3 id="引起互斥的原因"><a href="#引起互斥的原因" class="headerlink" title="引起互斥的原因"></a>引起互斥的原因</h3><p>与时间相关错误：一种与进程的推进速度有关的错误。</p><p>发生与时间相关错误的原因：1.交叉 2.涉及到公共变量。<br>根本原因：多个进程同时对变量  $$x$$ 操作，就是并发竞争对共享资源产生竞争。</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>进程互斥定义：两个或两个以上的进程不能同时进入就是使用，访问关于同一组共享变量的临界区,否则可能发生与时间有关的错误（间接制约）,这种现象被称作进程互斥。</p><p>临界资源：可被多个进程访问的变量。（公共变量、共享变量）</p><p>临界区：访问临界资源的程序段。（临界段）</p><p>进程互斥实现原则</p><p>临界区的管理原则（3个）：</p><ol><li>互斥性原则：任意时刻最多只能有一个进程处于关于同一组共享变量的临界区中。</li><li>有限等待性原则：一个请求进入临界区的进程，应在有限时间内能够进入临界区。</li><li>进展性原则：临界区空闲时，竞争临界区的多个进程在有限时间内确定下一个进入临界区的进程。</li></ol><p>临界区资源的调度原则（3个）：</p><ol><li><p>当关于某一组共享变量的所有临界区均为空闲时，一个要求进入该组共享变量某一临界区的进程应当能够立即进入</p></li><li><p>当关于某一组共享变量的所有临界区被占用时，一个要求进入该组共享变量某一临界区的进程应等待</p></li><li><p>当一个进程离开某一共享变量的某一临界区时，应允许某一处于等待的进程进入。</p></li></ol><p>五大原则：空闲让进，忙则等待，有限等待，让权等待，驻留有限</p><h4 id="互斥软件与硬件实现"><a href="#互斥软件与硬件实现" class="headerlink" title="互斥软件与硬件实现"></a>互斥软件与硬件实现</h4><p>软件实现：</p><p>Dekker算法</p><img src="https://s2.loli.net/2022/07/16/YlIEjeFyWG7O1DP.png" alt="image-20220601202338825" style="zoom:50%;"><p>面包店算法</p><img src="https://s2.loli.net/2022/07/16/mP8HhfNj4JVMBaD.png" alt="image-20220601203342102" style="zoom:50%;"><img src="https://s2.loli.net/2022/07/16/Hy9DsFnRVWot5Gv.png" alt="image-20220601203404535" style="zoom:50%;"><h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p>测试并建立指令：取出内存单元的值，再该单元赋上一个新值</p><p>交换指令：将两个内存单元中的内容交换</p><p><del>公平性互斥算法</del><br><img src="https://s2.loli.net/2022/07/16/ZNP95rRoEydnpk1.png" alt="image-20220601203730348" style="zoom:50%;"></p><p>开关中断指令：进程进入临界区，关中断；离开临界区，开中断<br>优点：实现效率高、不存在忙式等待、简单易行<br>缺点：仅在单CPU有效、影响系统并发性</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h4><p>定义：一组进程，为了协调其推进速度，在某些点处需要相互等待与相互唤醒，进程之间的这种相互制约关系。</p><p>注意：进程互斥可发生在任意两个进程之间，进程同步发生于具有逻辑关系的进程之间。</p><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><h5 id="信号灯与PV操作"><a href="#信号灯与PV操作" class="headerlink" title="信号灯与PV操作"></a>信号灯与PV操作</h5><p>原语：一段不可间断执行的程序</p><p>P操作对应申请资源、V操作对应释放资源</p><img src="https://s2.loli.net/2022/07/16/hNzoVUSAyT6GYEL.png" alt="image-20220619112419381" style="zoom:50%;"><p>Ø P原语操作的动作是： 指的是记录型信号量<br> （1）    sem减1；<br> （2）    若sem减1后仍大于或等于零，则进程继续执行；<br> （3）    若sem减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转进程调度。</p><p>Ø V原语操作的动作是： 指的是记录型信号量<br> （1）    sem加1；<br> （2）    若相加结果大于零，则进程继续执行；<br> （3）    若相加结果小于或等于零，则从该信号的等待队列中唤醒一等待进程，然后再返回原进程继续执行或转进程调度。</p><p>注意：就是P,V操作对于每一个进程来说，都只能进行一次。而且必须成对使用。且在P,V原语执行期间不允许有中断的发生。</p><p>进程同步：进程严格轮流执行</p><p>进程互斥：瞎几把执行，可能也会像进程同步一样轮流执行。</p><p>进程同步和互斥的判断：那么我们怎么来做题呢？首先我们看到进程同步比进程互斥的要求更强，条件更严格，因为它是严格要轮流执行的；而进程互斥可能在巧合时，是轮流执行的。从这点考虑：我们判断两个进程之间关系，如果是进程同步，那就不用再考虑他们之间的互斥（因为肯定满足互斥），这是个做此类题的原则；如果只有互斥，那就没啥。</p><p><strong>第一步：确定是进程同步还是进程互斥还是混合问题？</strong></p><p>如果：进程之间只有公有资源的竞争，就是进程互斥问题；</p><p>如果：同样的进程之间有公有资源的竞争也有直接制约，则只考虑直接制约的进程同步问题。如例3。生产者和消费者问题的第一例子。</p><p>如果：一些进程之间是进程同步问题，另一些进程之间是进程互斥问题，则是混合问题。如生产者和消费者问题的第三例子</p><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><p>1.一个生产者、一个消费者、共用一个缓冲区</p><img src="https://s2.loli.net/2022/07/16/NgyFzXo2PbpOE9j.png" alt="image-20220619162540091" style="zoom:50%;"><p>2.一个生产者、一个消费者、共用n个环形缓冲区</p><img src="https://s2.loli.net/2022/07/16/fNPs9ytgIJncV2x.png" alt="image-20220619162733874" style="zoom:50%;"><p>3.一组生产者，一组消费者，公用n个环形缓冲区</p><img src="https://s2.loli.net/2022/07/16/f3lN4DzF6WvUmYe.png" alt="image-20220619162820365" style="zoom:50%;"><h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5><p>问题：一个数据对象（数据文件或记录）可被多个进程共享。其中，reader进程要求读，writer 进程要求写或修改。允许多个reader进程同时读共享数据，但绝不允许一个writer进程与其它的reader进程或writer进程同时访问，即writer进程必须与其它进程互斥访问共享对象。</p><p>分析：<br>首先：进程是读者进程和写者进程。</p><p>同步：无，因为要求中没有说明读者和写者要合作。</p><p>互斥：读者和写者之间有互斥；写者之间有互斥。</p><p>其次：信号量及其值。虽然进程种类不同，但是抢的资源相同，就这么一个，因此公有信号量的值是1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">semaphore  rmutex=<span class="number">1</span>;  </span><br><span class="line">semaphore  wmutex=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span>  readcount=<span class="number">0</span>; </span><br><span class="line"><span class="built_in">Main</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">cobegin</span></span><br><span class="line"><span class="function">     <span class="title">reader</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="built_in">writer</span>();</span><br><span class="line">  coend</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个题最好把操作执行顺序画图。再判断</span></span><br><span class="line"><span class="built_in">Reader</span>()   </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">p</span>(rmutex); </span><br><span class="line">     <span class="keyword">if</span>(readcount==<span class="number">0</span>)  <span class="built_in">p</span>(wmutex);<span class="comment">/*第一位读者阻止写者*/</span></span><br><span class="line">  readcount++;   <span class="comment">//此语句是rmutex的临界区</span></span><br><span class="line">  <span class="built_in">V</span>(rmutex);  <span class="comment">//readcount是临界资源，readcount++是临界区，因此执行完，必须释放</span></span><br><span class="line">  读数据集； </span><br><span class="line">     <span class="built_in">p</span>(rmutex); </span><br><span class="line">     readcount--;     <span class="comment">//此语句是rmutex的临界区</span></span><br><span class="line">     <span class="keyword">if</span>(readcount==<span class="number">0</span>) <span class="built_in">v</span>(wmutex);<span class="comment">/*第末位读者允许写者进即只有最后一位读者出去，才执行v(wmutex)。*/</span></span><br><span class="line">     <span class="built_in">V</span>(rmutex);                       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Writer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">p</span>(wmutex); <span class="comment">//阻止其它进程（读、写）进</span></span><br><span class="line">       写数据集； </span><br><span class="line"> <span class="built_in">V</span>(wmutex); <span class="comment">//允许其它进程（读、写）进</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><p>5个哲学家围坐成一个圈，左右手各放着一只筷子，思考完了就拿起筷子吃饭。</p><p>我们用数组表示最合适：<strong>semaphore stick[5]={1,1,1,1,1};</strong> </p><p>解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Philosopher（<span class="keyword">int</span> i）</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    思考;  </span><br><span class="line">    p(stick[i]); </span><br><span class="line">    P(stick[(i+<span class="number">1</span>)%<span class="number">5</span>]); </span><br><span class="line">    进餐； </span><br><span class="line">    V(stick[i]);</span><br><span class="line">    V(stick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>死锁情况：每人都拿起左侧的筷子<br>死锁解决：1. 限制只让四个人吃饭。至多只允许四位哲学家同时去拿左边的筷子，这样就保证至少有一位哲学家能进餐并释放筷子，得以让其他人进餐。2、 仅当哲学家的左，右筷子都可用时，才允许他拿起进餐。3、规定奇数号哲学家先拿他左边的筷子，再拿右边的筷子；偶数的哲学家相反。这样也总保证一位哲学家能够得到筷子进餐。</p><p>例：有桥如下图所示，车流如箭头所示，桥上不允许两车交汇，但允许同方向多辆车依次通过（即桥上可以有多个同方向的车）。用P、V操作实现交通管理以防止桥上堵塞【北京大学 1992】</p><p><img src="https://img-blog.csdn.net/20180405154543432" alt="img"></p><p><strong>解析：</strong>这个题目要解决：南、北互斥（桥上不允许两车交汇，相当于“读、写互斥”），需要设置一个互斥信号量mutex，初值为1；南、南共享（相当于“读、读共享”），套用实现“读、读共享”的模式，需要设置一个共享变量southcount，用于记录当前桥上向南行驶过桥的车辆数目，初值为0，再设置一个互斥信号量smutex，实现对southcount的互斥访问；北、北共享（也相当于“读、读共享”），套用实现“读、读共享”的模式，同理可得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 作为桥的互斥访问信号量</span></span><br><span class="line">semaphore smutex = <span class="number">1</span>;<span class="comment">// 作为southcount的互斥访问信号量</span></span><br><span class="line">semaphore nmutex = <span class="number">1</span>;<span class="comment">// 作为northcount的互斥访问信号量</span></span><br><span class="line"><span class="keyword">int</span> southcount = <span class="number">0</span>;<span class="comment">// 记录南方向的车辆的数量</span></span><br><span class="line"><span class="keyword">int</span> northcount = <span class="number">0</span>;<span class="comment">// 记录北方向的车辆的数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">south</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">P(smutex);</span><br><span class="line"><span class="keyword">if</span>(southcount == <span class="number">0</span>)</span><br><span class="line">P(mutex);    <span class="comment">//没车就申请资源，阻止另一方向的车</span></span><br><span class="line">southcount++;</span><br><span class="line">V(smutex);</span><br><span class="line"><span class="comment">// 南方车辆通过</span></span><br><span class="line">P(smutex);</span><br><span class="line">southcount--;</span><br><span class="line"><span class="keyword">if</span>(southcount == <span class="number">0</span>)</span><br><span class="line">V(mutex);</span><br><span class="line">V(smutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">north</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">P(nmutex);</span><br><span class="line"><span class="keyword">if</span>(northcount == <span class="number">0</span>)</span><br><span class="line">P(mutex);</span><br><span class="line">northcount++;</span><br><span class="line">V(nmutex);</span><br><span class="line"><span class="comment">// 北方车辆通过</span></span><br><span class="line">P(nmutex);</span><br><span class="line">northcount--;</span><br><span class="line"><span class="keyword">if</span>(northcount == <span class="number">0</span>)</span><br><span class="line">V(mutex);</span><br><span class="line">V(nmutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号量的当前值如果是正值N，该值表示有N个可用资源。<br>如果为0，则表示所有资源全部被分配，同时没有进程处于等待状态<br>如果为负数N，则表示全部资源分配完毕，且还有N个进程处于等待该资源的状态。</p><p>条件信号量</p><h3 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a><del>进程通讯</del></h3><p>进程之间的互斥、同步及信息交换统称进程通讯</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ch4-互斥同步与通讯&quot;&gt;&lt;a href=&quot;#Ch4-互斥同步与通讯&quot; class=&quot;headerlink&quot; title=&quot;Ch4_互斥同步与通讯&quot;&gt;&lt;/a&gt;Ch4_互斥同步与通讯&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Computer Science" scheme="https://zhangjy1014.github.io/categories/Computer-Science/"/>
    
    
    <category term="OS" scheme="https://zhangjy1014.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Ch5_死锁和饥饿</title>
    <link href="https://zhangjy1014.github.io/2023/03/24/Ch5-%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/"/>
    <id>https://zhangjy1014.github.io/2023/03/24/Ch5-%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/</id>
    <published>2023-03-24T12:41:25.000Z</published>
    <updated>2023-03-24T13:40:58.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch5-死锁和饥饿"><a href="#Ch5-死锁和饥饿" class="headerlink" title="Ch5_死锁和饥饿"></a>Ch5_死锁和饥饿</h1><p>[toc]</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h2><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><p>定义：由于进程竞争资源而形成的僵持状态。<br>           一组进程中的每个进程均等待此组进程中某一其它进程占有的、因而永远无法得到的资源, 这种因进程竞争资源而引起的僵持现象称<strong>进程死锁</strong>。</p><p>几个有用结论：</p><p>   (1)参与死锁的进程数至少为二；</p><p>   (2)参与死锁的所有进程均等待资源；</p><p>   (3)参与死锁的进程至少有两个已占有资源；</p><p>   (4)参与死锁的进程是系统中当前正在运行进程集合的一个子集。</p><p>死锁发生的四个必要条件：</p><p>​    (1) <strong>资源独占</strong>：一个资源仅分配给一个进程。如果进程申请某一资源, 而该资源正被另一进程占用, 则申请者需等待, 直到占有者释放该资源。也叫<strong>互斥条件</strong></p><p>​    (2)<strong>不可剥夺</strong>：资源申请者不能从资源占有者手中抢夺资源</p><p>​    (3)<strong>保持申请</strong>，即进程占有部分资源后还可申请新的资源, 且申请新资源时并不释放已占有资源。<strong>也叫请求保持条件。</strong></p><p>​    (4)<strong>循环等待</strong>：进程p<del>1</del>等待p<del>2</del>的资源占有的，p<del>2</del>等待p<del>3</del>占有的资源…p<del>n</del>等待p<del>1</del>占有的资源</p><p>==死锁的产生当且仅当四个条件同时满足！！==<br>==破坏一个条件死锁就不会发生。==</p><h4 id="死锁的类型（3大原因）"><a href="#死锁的类型（3大原因）" class="headerlink" title="死锁的类型（3大原因）"></a>死锁的类型（3大原因）</h4><p>​    (1)资源竞争引起：竞争有限资源</p><p>​    (2)进程通信引起：互相等待消息</p><p>​    (3)其他原因after you：互相谦让</p><h4 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h4><h5 id="四大策略"><a href="#四大策略" class="headerlink" title="四大策略"></a>四大策略</h5><p>不让死锁发生：预防、避免</p><p>让死锁发生：检测、解除（恢复）</p><h5 id="静态动态"><a href="#静态动态" class="headerlink" title="静态动态"></a>静态动态</h5><p>静态：在进程未申请资源时就限制有关活动</p><p>动态：在进程申请资源时加以实时检测，拒绝不安全的申请</p><p>静态预防、动态避免、动态检测、动态解除</p><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>描述资源分配情况。</p><p>圆圈-&gt;进程； 资源类-&gt;方框；资源类的子资源-&gt;圆点。</p><p>申请资源：P<del>i</del>向R<del>j</del>申请资源，画一条申请边（有向边），若可满足，改为分配边。</p><p>释放资源：进程释放资源，去掉对应的分配边。</p><img src="https://s2.loli.net/2022/07/16/o4HfmbetcAPOsqT.png" alt="image-20220531215700356" style="zoom:50%;"><p>资源分配图无环路，代表无死锁。</p><p>存在环路，意味着可能死锁，也可能没死锁</p><p>一个资源类只有一个资源且有环路，必死锁；多个资源有环路则不一定死锁</p><h5 id="资源分配图约简步骤"><a href="#资源分配图约简步骤" class="headerlink" title="资源分配图约简步骤"></a>资源分配图约简步骤</h5><p>(1) 寻找一个非孤立且<strong>没有请求边</strong>的进程结点p<del>i</del> , 若无，则算法结束；<strong>没有请求边说明资源全部得到</strong></p><p>(2) 去除P<del>i</del> 的所有分配边使P<del>i</del> 成为一个孤立结点；</p><p>(3) 寻找所有请求边均可满足的进程<em>P<del>j</del></em>,将<em>P<del>j</del></em> 的请求边全部改为分配边；</p><p>(4) 转步骤(1)。</p><h5 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h5><p>S<em>为死锁状态的==充分必要条件==是</em>S的资源分配图不可完全约简。</p><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>破坏死锁产生的四个必要条件之一</p><h4 id="破坏四个条件"><a href="#破坏四个条件" class="headerlink" title="破坏四个条件"></a>破坏四个条件</h4><p>​    (1)破坏互斥条件：允许多个进程同时访问资源<br>​    (2)破坏请求和保持条件：预先静态分配，进程开始前就完成对所有资源的申请<br>​    (3)破坏不可剥夺条件：就是剥夺资源，实现复杂性很高<br>​    (4)破坏环路条件，有序分配算法：对系统所有资源编号，进程对资源的请求必须严格资源序号的从低到高申请</p><h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><h4 id="一些概念-1"><a href="#一些概念-1" class="headerlink" title="一些概念"></a>一些概念</h4><p>指在某一时刻，系统能按某种进程顺序(p1,p2,…，pn)来为每个进程Pi分配其资源,直到满足每个进程对资源的最大需求,使每个进程都可顺利地完成，则称此时的系统状态为==安全状态==。 序列(p1,p2,…，pn)为==安全序列==。若系统的某一时刻不存在安全序列，则此时的系统处于==不安全状态==。</p><p>一个结论：安全状态一定没有死锁，不安全状态可能有死锁</p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>资源预分配算法<br><img src="https://s2.loli.net/2022/07/16/qfbDmjNQG3etYRu.png" alt="image-20220601155954469" style="zoom:30%;"></p><p>安全性检测算法<br><img src="https://s2.loli.net/2022/07/16/gOIwVepxBCNizDo.png" alt="image-20220601160029384" style="zoom:32%;"></p><p>银行家算法的保守性的原因：是指银行家算法只给出了进程需要资源的最大量，而所需资源的具体申请和释放顺序仍是未知的，因而银行家只能往最坏处设想。</p><p>银行家算法例：</p><img src="https://s2.loli.net/2022/07/16/nGJtu4jioNfrxED.png" alt="image-20220619102002867" style="zoom:33%;"><img src="https://s2.loli.net/2022/07/16/EY8KM2sBQ9oFTbD.png" alt="image-20220619101449935" style="zoom:30%;"><img src="https://s2.loli.net/2022/07/16/Tc7rfzD5tyjCsJ6.png" alt="image-20220619101735801" style="zoom:30%;"><img src="https://s2.loli.net/2022/07/16/MsIPUdecBrTRgfZ.png" alt="image-20220619101907682" style="zoom:30%;"><p>​    </p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><h4 id="死锁的检测算法"><a href="#死锁的检测算法" class="headerlink" title="死锁的检测算法"></a>死锁的检测算法</h4><img src="https://s2.loli.net/2022/07/16/hHEF3Qnk1MTuwbI.png" alt="image-20220601161157951" style="zoom:50%;"><h3 id="解除（恢复）"><a href="#解除（恢复）" class="headerlink" title="解除（恢复）"></a>解除（恢复）</h3><ol><li>关闭进程</li><li>重新启动</li><li>剥夺资源、进程回退</li></ol><p>鸵鸟算法</p><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a><strong>饥饿</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>饥饿：没有时间上界的等待：排队等待、忙式等待（等待态，就绪态，运行态）</p><p>饿死：当一个进程的等待时间超过极限，即使最后完成了也没有意义</p><h3 id="饿死和死锁的区别（4条）"><a href="#饿死和死锁的区别（4条）" class="headerlink" title="饿死和死锁的区别（4条）"></a>饿死和死锁的区别（4条）</h3><p><strong>死锁进程处于等待状态，饿死则不然；</strong>从进程状态考虑，死锁进程都处于等待状态，忙式等待(处于运行或就绪状态)的进程并非处于等待状态，但却可能被饿死.<br><strong>死锁可以检测，饿死不然</strong>；死锁一定有循环等待，而饿死不然；这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死.<br><strong>死锁一定涉及多个进程，而饥饿或饿死的进程可能只有一个；</strong><br><strong>死锁等待的资源不会释放，而饿死等待的资源会释放但却不会分配给它，其等待无上界；</strong></p><h2 id="同种可复用资源死锁的必要条件"><a href="#同种可复用资源死锁的必要条件" class="headerlink" title="同种可复用资源死锁的必要条件"></a><strong>同种可复用资源死锁的必要条件</strong></h2><p>同种资源！</p><p>前提是==N个进程==所需的是某类资源的多个==资源实例M==；</p><p>每个进程至少需要一个资源实例 当所有进程所需资源总量满足==∑≥M+N==，必发生死锁；</p><p>结论：若所需资源总量，<br>     当∑&lt; M+N时，一定无死锁。<br>     当∑≥M+N时，至少一个交叉有死锁。</p><p>例如：设资源量=16，p1需要5个，p2需要6个，p3需要4个，p4<br>需要4个。<br>此时，∑=5+6+4+4=19，M+N=20，∑&lt;M+N，因此无死锁。<br>若p4需要5个，其余不变，则∑=M+N，则有可能死锁。<br>事实上，当p1得到4个，p2得到5个，p3得到3个，p4得到4个<br>是，将发生死锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ch5-死锁和饥饿&quot;&gt;&lt;a href=&quot;#Ch5-死锁和饥饿&quot; class=&quot;headerlink&quot; title=&quot;Ch5_死锁和饥饿&quot;&gt;&lt;/a&gt;Ch5_死锁和饥饿&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=</summary>
      
    
    
    
    <category term="Computer Science" scheme="https://zhangjy1014.github.io/categories/Computer-Science/"/>
    
    
    <category term="OS" scheme="https://zhangjy1014.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Ch7_文件系统</title>
    <link href="https://zhangjy1014.github.io/2023/03/24/Ch7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zhangjy1014.github.io/2023/03/24/Ch7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-03-24T12:41:25.000Z</published>
    <updated>2023-03-24T13:41:31.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch7-文件系统"><a href="#Ch7-文件系统" class="headerlink" title="Ch7_文件系统"></a>Ch7_文件系统</h1><p align="center"><a href="https://github.com/zhangjy1014" target="view_window"><img alt="GitHub" src="https://img.shields.io/badge/Github-@zhangjy1014-000000.svg?style=flat-square&logo=Github"></a><a href="https://space.bilibili.com/434002748"><img src="https://img.shields.io/badge/B%E7%AB%99-@Lil_SuiSad-000000.svg?style=flat-square&logo=Bilibili"></a></p><p>[toc]</p><h2 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a>文件与文件系统</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件的概念：<strong>文件</strong>是具有符号名且逻辑上具有完整意义的信息项的有序序列。文件是具有文件名的一组相关元素的集合。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统的概念：文件与管理信息的程序集合称为<strong>文件系统</strong></p><p>文件系统的功能：</p><ol><li>为用户提供按名存取文件的手段</li><li>管理文件</li><li>管理外存</li></ol><h3 id="文件的访问方式"><a href="#文件的访问方式" class="headerlink" title="文件的访问方式"></a>文件的访问方式</h3><ol><li><p>顺序访问：从前到后的顺序依次存取文件的各个信息项。</p><p>​    1.由文件头顺序访问。由文件起始位置开始依此访问文件的各个信息项。</p><p>​    2.由文件内开始顺序访问。由文件的某一位置开始依次访问文件的各个信息项。</p></li><li><p>随机访问：无序存取文件的信息项</p><ol><li>按号随机访问。按信息项的编号随机存取文件的某些信息项</li><li>按键随机访问。键是文件信息项中的一个域。按键随机访问指按信息项中的某个关键值随机存取文件记录。</li></ol></li></ol><h3 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h3><p>文件目录中的每一项就是文件目录项</p><p>文件目录项就是文件控制块FCB</p><p>文件的逻辑组织：文件的外部组织形式，用户看到的文件组织形式</p><ol><li>流式文件：无结构式，OS对流式文件的外部结构没有解释。具有符号名且逻辑上意义完整的字节序列。如可执行文件</li><li>记录式文件：结构式。OS对记录式文件的外部结构有解释。具有符号名且逻辑上意义完整的记录序列。</li></ol><p>文件的物理组织：文件的内部组织形式，在物理存储设备上的组织形式。也就是存储方式。<br>文件常用的物理组织形式：</p><ol><li><p>顺序结构。该种文件占用连续的物理块号，首块号及块数存放在FCB中。<br>优点：访问速度快。缺点：容易产生碎片、不容易增加长度</p></li><li><p>链接结构。不必使用连续的物理块。采用链接分配方式时，通过每个物理块上的链接指针，将属于同一个文件的物理块链接成一个链表，这样形成的物理文件就称为链接式文件。<br>优点：长度动态变化容易、消除了碎片。缺点：随机访问速度慢、分配表也占用大量内存空间。</p></li><li><p>索引结构。采用索引分配方式的文件。就是一个文件占用的若干不连续的存储块的块号记录于一个索引块中。</p><img src="https://s2.loli.net/2022/07/16/toHuiZ2TrPYjUOs.png" alt="image-20220618213104748" style="zoom:33%;">优点: 访问速度快,长度变化容易，没有碎片。<p>缺点: 索引块本身占内存,存储开销大。</p></li><li><p>散列结构</p></li><li><p>倒排结构</p></li></ol><p>比较<br><img src="https://s2.loli.net/2022/07/16/e4EuGi2QbvNacFy.png" alt="image-20220618213251473" style="zoom:50%;"></p><h2 id="文件目录与目录文件"><a href="#文件目录与目录文件" class="headerlink" title="文件目录与目录文件"></a>文件目录与目录文件</h2><p><strong>文件目录与目录文件</strong>是同一事物的两种称谓。从用途角度，称文件目录; 从实现角度，称目录文件。用途是文件的目录，存在形式是目录组成的文件</p><p><strong>文件目录</strong>:用于检索文件的目录称文件目录,它是由目录项构成的有序序列。就是FCB的集合。给定一个文件名,通过查找文件目录便可找到该文件名对应的目录项(FCB)。</p><p><strong>目录文件</strong>: 为实现对文件目录的管理,将文件目录作为文件保存于<strong>外存</strong>,该文件称目录文件。目录文件是长度固定的记录式文件每一个记录就是文件控制块FCB。</p><h3 id="单级目录"><a href="#单级目录" class="headerlink" title="单级目录"></a>单级目录</h3><p>整个目录系统中只有一个目录，所有文件都存放在这个目录下。优点：简单；缺点：文件不能重名</p><h3 id="二级目录"><a href="#二级目录" class="headerlink" title="二级目录"></a>二级目录</h3><p>==系统目录==：采用二级目录时，整个系统有一个公共目录<br>==用户目录==：每个用户有一个私有目录<br>==形式与内容==：所有用户目录位于系统目录内，每个用户目录记录该用户的文件。<br>==优点==：每个用户有自己的私用目录,因而不同用户可以用相同的文件名。<br>==缺点==:(1)不能将文件加以分类；   (2)用户文件较多时查找速度较慢。</p><h3 id="多级目录"><a href="#多级目录" class="headerlink" title="多级目录"></a>多级目录</h3><p>多级目录构成一个倒向生长的树形结构。</p><p>叶结点是一般文件或目录文件；</p><p>非叶结点是目录文件；</p><p>根结点是特殊目录文件(根目录文件)。</p><img src="https://s2.loli.net/2022/07/16/9HZALlSb8sg1eu4.png" alt="image-20220618214421642" style="zoom:33%;"><p>优点：</p><p>1）便于文件分类，可以为每个文件建立一个子目录；</p><p>2）提高文件检索速度，因为每个目录下的文件数目较少；</p><p>3）可以实现文件的链接。</p><p>缺点：</p><p>查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度。</p><h3 id="文件目录的改进"><a href="#文件目录的改进" class="headerlink" title="文件目录的改进"></a>文件目录的改进</h3><p><strong>改进方法：</strong>将FCB分成FCB次部, FCB主部。FCB即目录项作为一组与文件相关的信息保存在一起。实现时，有些系统将它分为两部分: FCB次部, FCB主部。</p><p>•<strong>次部：</strong>仅包括文件名和文件号，<strong>保存在目录文件中</strong>。目录文件变小</p><p>•<strong>主部：</strong>包括除文件名外的所有信息和一个连接计数，连接计数值为0时表示一个空闲未用的FCB主部。<strong>主部保存在外存</strong>。</p><p>改进的好处：</p><p>可以提高查找速度(顺序查找)</p><p>可以实现文件链接(link)</p><img src="https://s2.loli.net/2022/07/16/Ev6OpHfkziQYuIj.png" alt="image-20220618215217130" style="zoom:50%;"><p>根目录和当前目录</p><p>文件目录的查找</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ch7-文件系统&quot;&gt;&lt;a href=&quot;#Ch7-文件系统&quot; class=&quot;headerlink&quot; title=&quot;Ch7_文件系统&quot;&gt;&lt;/a&gt;Ch7_文件系统&lt;/h1&gt;&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://github.com/zh</summary>
      
    
    
    
    <category term="Computer Science" scheme="https://zhangjy1014.github.io/categories/Computer-Science/"/>
    
    
    <category term="OS" scheme="https://zhangjy1014.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Ch8_IO设备管理</title>
    <link href="https://zhangjy1014.github.io/2023/03/24/Ch8-IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <id>https://zhangjy1014.github.io/2023/03/24/Ch8-IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-24T12:41:25.000Z</published>
    <updated>2023-03-24T13:41:59.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch8-IO设备管理"><a href="#Ch8-IO设备管理" class="headerlink" title="Ch8_IO设备管理"></a>Ch8_IO设备管理</h1><p>[toc]</p><h3 id="磁盘组的物理特性"><a href="#磁盘组的物理特性" class="headerlink" title="磁盘组的物理特性"></a>磁盘组的物理特性</h3><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620102345783.png" style="zoom:33%;"><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620102534078.png" alt="image-20220620102534078" style="zoom:33%;"><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620102928117.png" alt="image-20220620102928117" style="zoom:33%;"><p>总扇区数=柱面数×盘面数×扇区数(一个盘面的扇区数)</p><p>块号=字号×字长+位号</p><p>柱面号=[块号/柱面上的块数]</p><p>磁头（盘面）号=[（块号mod柱面上的块数）/盘面上的扇区数]</p><p>扇区号=（块号mod柱面上的块数）mod盘面上的扇区数</p><h3 id="I-O传输方式"><a href="#I-O传输方式" class="headerlink" title="I/O传输方式"></a>I/O传输方式</h3><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>–处理器代表进程向相应的设备模块发出I/O请求，然后处理器反复查询设备状态，直到I/O完成。<br>缺点：处理机与设备串行工作；忙等，消耗大量处理机时间</p><h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><p>１）需要数据的进程向CPU发出指令启动I/O设备输入数据。</p><p>２）该进程放弃处理机，等待输入完成。CPU执行其他任务。</p><p>３）<strong>输入完成后</strong>，I/O控制器向CPU发出中断请求，CPU收到后，转向中断服务程序。中断服务程序将<strong>数据输入寄存器</strong>中的数据送到指定的内存单元，并将原进程唤醒，继续执行。</p><p>４）之后，该进程再被调度，从内存单元取出数据进行处理。</p><p>  优点：<br>　　  CPU利用率大大提高。（相对于忙等待方式）<br>  缺点：<br>      每台设备每输入/出一个字（节）的数据都有一次中断。如果设备较多时，中断次数会很多，使CPU的计算时间大大减少。<br>      不适合块设备。中断次数多，效率极低。<br>      为减少中断对CPU造成的影响，可采用DMA方式和通道方式。</p><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p><strong>是在外围设备和内存之间直接进行数据交换。</strong> 除了有中断功能外，还有DMA控制器。在DMA控制器的控制下，设备同主存之间可成批交换数据，不用CPU干预。</p><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620105704704.png" alt="image-20220620105704704" style="zoom:33%;"><p>优点—CPU利用率进一步提高（并行度有所提高）。</p><p>缺点—数据传送方向、字节数、内存地址等需<strong>由CPU控制</strong>，且<strong>一台</strong>DMA控制器控制<strong>一台</strong>设备，设备增多时，不经济。</p><p>==中断方式与DMA方式区别==</p><p>  中断方式是在数据缓冲寄存器满后，发中断请求，CPU进行中断处理；DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理； ——大大减少了CPU进行中断处理的次数。</p><p>  中断方式的数据传送是由CPU控制完成的；DMA方式则是在DMAC的控制下完成的。</p><h4 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h4><p>​     为使CPU从繁忙的I/O处理中摆脱出来，现代大、中型计算机系统中设置了专门处理I/O操作的处理机，并把这种处理机称为通道。通道=I/O处理机<br>​     优点：一个通道可控制多设备，所需CPU干预更少。      CPU利用率较高</p><h3 id="设备调度（磁盘调度算法）"><a href="#设备调度（磁盘调度算法）" class="headerlink" title="==设备调度（磁盘调度算法）=="></a>==设备调度（磁盘调度算法）==</h3><h4 id="先到先服务（FCFS）"><a href="#先到先服务（FCFS）" class="headerlink" title="先到先服务（FCFS）"></a>先到先服务（FCFS）</h4><p>简单、效率低，适合I/O负载较轻的系统</p><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620110723640.png" alt="image-20220620110723640" style="zoom:33%;"><h4 id="最短寻找时间优先（SSTF）"><a href="#最短寻找时间优先（SSTF）" class="headerlink" title="最短寻找时间优先（SSTF）"></a>最短寻找时间优先（SSTF）</h4><p>存在公平性和饥饿问题</p><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620110832479.png" alt="image-20220620110832479" style="zoom:33%;"><h4 id="SCAN和LOOK算法（电梯算法）"><a href="#SCAN和LOOK算法（电梯算法）" class="headerlink" title="SCAN和LOOK算法（电梯算法）"></a>SCAN和LOOK算法（电梯算法）</h4><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620111043086.png" alt="image-20220620111043086" style="zoom:33%;"><h4 id="C-SCAN算法"><a href="#C-SCAN算法" class="headerlink" title="C-SCAN算法"></a>C-SCAN算法</h4><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620111119614.png" alt="image-20220620111119614" style="zoom:33%;"><h3 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3><p>概念：处理数据到达与离开速度不一致所采用的技术。</p><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620111345323.png" alt="image-20220620111345323" style="zoom:33%;"><h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><img src="https://raw.githubusercontent.com/zhangjy1014/picgo/master/img/image-20220620111411628.png" alt="image-20220620111411628" style="zoom:33%;"><h4 id="虚拟设备"><a href="#虚拟设备" class="headerlink" title="虚拟设备"></a>虚拟设备</h4><p>基本原理：在进程与独占型设备之间增加共享设备缓冲</p><p>输入时：数据从独占设备<strong>连续传输</strong>到共享设备上缓冲</p><p>输出时：数据从进程<strong>间断传输</strong>到共享设备上缓冲。多个进程并发</p><p>SPOOLing 技术就是利用一道程序（SPOOLing程序）来模拟外围控制机，完成对设备的I/O操作。是一项将独占设备改造成为共享设备的技术。<strong>既是虚拟设备，又有假脱机技术</strong></p><h5 id="SPOOLing-假脱机-系统的特点"><a href="#SPOOLing-假脱机-系统的特点" class="headerlink" title="SPOOLing(假脱机)系统的特点"></a>SPOOLing(假脱机)系统的特点</h5><p>​    提高了I/O的速度，缓和了CPU与I/O设的速度矛盾；</p><p>​    将独占设备改造为共享设备：利用高速共享设备；</p><p>​    实现了虚拟设备功能：用户都感到独占了一台设备</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ch8-IO设备管理&quot;&gt;&lt;a href=&quot;#Ch8-IO设备管理&quot; class=&quot;headerlink&quot; title=&quot;Ch8_IO设备管理&quot;&gt;&lt;/a&gt;Ch8_IO设备管理&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;磁盘组的物理特性&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Computer Science" scheme="https://zhangjy1014.github.io/categories/Computer-Science/"/>
    
    
    <category term="OS" scheme="https://zhangjy1014.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>基于距离向量算法的路由协议RIP</title>
    <link href="https://zhangjy1014.github.io/2022/01/15/RIP-Route/"/>
    <id>https://zhangjy1014.github.io/2022/01/15/RIP-Route/</id>
    <published>2022-01-15T08:42:27.000Z</published>
    <updated>2022-01-19T08:10:07.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>理解基于距离向量算法的路由协议 RIP。</p><h2 id="二、实验内容和要求"><a href="#二、实验内容和要求" class="headerlink" title="二、实验内容和要求"></a>二、实验内容和要求</h2><p>1、用 Cisco Packet Tracer 研究 RIP；</p><p>2、支持多个路由器；</p><p>3、学习使用 Cisco Packet Tracer 的 Simulation 模式，通过捕获的数据分析 RIP 报文格式，并在实验报告体现；</p><h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h3 id="3-1建立网络拓扑结构"><a href="#3-1建立网络拓扑结构" class="headerlink" title="3.1建立网络拓扑结构"></a>3.1建立网络拓扑结构</h3><p>在Packet Tracer中，建立如图所示的网络拓扑结构:</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/1.png" alt="1"></p><h3 id="3-2配置参数"><a href="#3-2配置参数" class="headerlink" title="3.2配置参数"></a>3.2配置参数</h3><h4 id="3-2-1-PC配置"><a href="#3-2-1-PC配置" class="headerlink" title="3.2.1 PC配置"></a>3.2.1 PC配置</h4><p>PC0的配置：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/2.png" alt="2"></p><p>PC1的配置：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/3.png" alt="3"></p><h4 id="3-2-2-Route-IP、RIP配置"><a href="#3-2-2-Route-IP、RIP配置" class="headerlink" title="3.2.2 Route IP、RIP配置"></a>3.2.2 Route IP、RIP配置</h4><p>Route A配置：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/4.png" alt="4"></p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/5.png" alt="5"><br>Route B配置：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/6.png" alt="6"></p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/7.png" alt="7"></p><p>Route C配置：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/8.png" alt="8"></p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/9.png" alt="9"></p><p>Route D配置：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/10.png" alt="10"></p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/11.png" alt="11"></p><p>Route E配置：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/12.png" alt="12"></p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/13.png" alt="13"></p><h3 id="3-3测试网络"><a href="#3-3测试网络" class="headerlink" title="3.3测试网络"></a>3.3测试网络</h3><h4 id="3-3-1连通性测试"><a href="#3-3-1连通性测试" class="headerlink" title="3.3.1连通性测试"></a>3.3.1连通性测试</h4><p>PC0、PC1分别使用ping命令，可见网络是连通的。</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/14.png" alt="14"></p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/15.png" alt="15"></p><h4 id="3-3-2使用Simulation模式查看网络及报文"><a href="#3-3-2使用Simulation模式查看网络及报文" class="headerlink" title="3.3.2使用Simulation模式查看网络及报文"></a>3.3.2使用Simulation模式查看网络及报文</h4><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/16.png" alt="16"></p><p>对报文进行分析</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/17.png" alt="17"></p><p>Layer1 是物理层，表示Route从GigabitEthernet0/1收到数据。</p><p>Layer2 是数据链路层，表示其MAC地址。</p><p>Layer3 是网络层，表示源地址和目的地址。</p><p>Layer4 是传输层，表示报文交接的端口。</p><p>Layer7 是应用层，表示协议及版本。</p><p>报文具体格式：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/18.png" alt="18"></p><p>Route A路由表：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/19.png" alt="19"></p><p>Route B路由表：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/20.png" alt="20"></p><p>Route C路由表：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/21.png" alt="21"></p><p>Route D路由表：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/22.png" alt="22"></p><p>Route E路由表：</p><p><img src="https://zhangjy1014.github.io/2022/01/15/RIP-Route/23.png" alt="23"></p><p>由此可见所有路由器都学到了网络的跳转路径。</p><p>附：<a href="https://zhangjy1014.github.io/2022/01/15/RIP-Route/4.pkt" title="4.pkt">Cisco Packet Tracer实验文件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、实验目的&quot;&gt;&lt;a href=&quot;#一、实验目的&quot; class=&quot;headerlink&quot; title=&quot;一、实验目的&quot;&gt;&lt;/a&gt;一、实验目的&lt;/h2&gt;&lt;p&gt;理解基于距离向量算法的路由协议 RIP。&lt;/p&gt;
&lt;h2 id=&quot;二、实验内容和要求&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Computer Science" scheme="https://zhangjy1014.github.io/categories/Computer-Science/"/>
    
    
    <category term="Computer Networks" scheme="https://zhangjy1014.github.io/tags/Computer-Networks/"/>
    
  </entry>
  
  <entry>
    <title>博客系统面向对象设计文档</title>
    <link href="https://zhangjy1014.github.io/2021/11/01/blog-object-oriented-design/"/>
    <id>https://zhangjy1014.github.io/2021/11/01/blog-object-oriented-design/</id>
    <published>2021-11-01T08:07:25.000Z</published>
    <updated>2022-03-01T08:13:28.533Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhangjy1014.github.io/2021/11/01/blog-object-oriented-design/blog-object-oriented-design.pdf" title="blog-object-oriented-design.pdf">博客系统面向对象设计文档</a></p><object data="https://zhangjy1014.github.io/2021/11/01/blog-object-oriented-design/blog-object-oriented-design.pdf" type="application/pdf" width="100%" height="877px"></object>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhangjy1014.github.io/2021/11/01/blog-object-oriented-design/blog-object-oriented-design.pdf&quot; title=&quot;blog-object-oriente</summary>
      
    
    
    
    <category term="Software Engineering" scheme="https://zhangjy1014.github.io/categories/Software-Engineering/"/>
    
    
    <category term="Software design" scheme="https://zhangjy1014.github.io/tags/Software-design/"/>
    
  </entry>
  
  <entry>
    <title>博客系统结构化设计文档</title>
    <link href="https://zhangjy1014.github.io/2021/11/01/blog-structured-design/"/>
    <id>https://zhangjy1014.github.io/2021/11/01/blog-structured-design/</id>
    <published>2021-11-01T07:50:29.000Z</published>
    <updated>2022-03-01T08:12:00.246Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhangjy1014.github.io/2021/11/01/blog-structured-design/blog-structured-design.pdf" title="blog-structured-design.pdf">博客系统结构化设计文档</a></p><object data="https://zhangjy1014.github.io/2021/11/01/blog-structured-design/blog-structured-design.pdf" type="application/pdf" width="100%" height="877px"></object>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhangjy1014.github.io/2021/11/01/blog-structured-design/blog-structured-design.pdf&quot; title=&quot;blog-structured-design.pdf&quot;&gt;博</summary>
      
    
    
    
    <category term="Software Engineering" scheme="https://zhangjy1014.github.io/categories/Software-Engineering/"/>
    
    
    <category term="Software design" scheme="https://zhangjy1014.github.io/tags/Software-design/"/>
    
  </entry>
  
  <entry>
    <title>博客系统结构化需求分析文档</title>
    <link href="https://zhangjy1014.github.io/2021/11/01/blog-structured-analysis/"/>
    <id>https://zhangjy1014.github.io/2021/11/01/blog-structured-analysis/</id>
    <published>2021-11-01T07:33:12.000Z</published>
    <updated>2022-03-01T08:11:18.419Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhangjy1014.github.io/2021/11/01/blog-structured-analysis/blog-structured-analysis.pdf" title="blog-structured-analysis.pdf">博客系统结构化需求分析文档</a></p><object data="https://zhangjy1014.github.io/2021/11/01/blog-structured-analysis/blog-structured-analysis.pdf" type="application/pdf" width="100%" height="877px"></object>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhangjy1014.github.io/2021/11/01/blog-structured-analysis/blog-structured-analysis.pdf&quot; title=&quot;blog-structured-analysis.</summary>
      
    
    
    
    <category term="Software Engineering" scheme="https://zhangjy1014.github.io/categories/Software-Engineering/"/>
    
    
    <category term="Software analysis" scheme="https://zhangjy1014.github.io/tags/Software-analysis/"/>
    
  </entry>
  
  <entry>
    <title>建站notation</title>
    <link href="https://zhangjy1014.github.io/2021/10/30/notation/"/>
    <id>https://zhangjy1014.github.io/2021/10/30/notation/</id>
    <published>2021-10-30T12:38:57.000Z</published>
    <updated>2022-01-15T08:50:41.160Z</updated>
    
    <content type="html"><![CDATA[<p>参考文档：1. <a href="https://dhndzwxj-3ghxc51j1010c2ed-1302940033.tcloudbaseapp.com/3276806131.html">https://dhndzwxj-3ghxc51j1010c2ed-1302940033.tcloudbaseapp.com/3276806131.html</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></p><p>valine评论框架：<a href="https://valine.js.org/">https://valine.js.org</a></p><p>评论管理工具：<a href="https://console.leancloud.cn/apps/K6CcYTognPssARuNej3sBRGI-gzGzoHsz/storage/data/Comment">https://console.leancloud.cn/apps/K6CcYTognPssARuNej3sBRGI-gzGzoHsz/storage/data/Comment</a></p><p>上传部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>命令顺序：<br><img src="https://zhangjy1014.github.io/2021/10/30/notation/sc.png" alt="sc"></p><p><img src="https://zhangjy1014.github.io/2021/10/30/notation/cat.gif" alt="cat"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文档：1. &lt;a href=&quot;https://dhndzwxj-3ghxc51j1010c2ed-1302940033.tcloudbaseapp.com/3276806131.html&quot;&gt;https://dhndzwxj-3ghxc51j1010c2ed-130294</summary>
      
    
    
    
    <category term="blog" scheme="https://zhangjy1014.github.io/categories/blog/"/>
    
    
    <category term="hexo" scheme="https://zhangjy1014.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo官方文档</title>
    <link href="https://zhangjy1014.github.io/2021/10/28/hello-world/"/>
    <id>https://zhangjy1014.github.io/2021/10/28/hello-world/</id>
    <published>2021-10-28T09:15:38.920Z</published>
    <updated>2021-10-30T12:00:39.950Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="blog" scheme="https://zhangjy1014.github.io/categories/blog/"/>
    
    
    <category term="hexo" scheme="https://zhangjy1014.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
